{
  "version": 3,
  "sources": ["../../../../../node_modules/@apollo/src/link/persisted-queries/index.ts"],
  "sourcesContent": ["import { invariant } from \"../../utilities/globals/index.js\";\n\nimport { print } from \"../../utilities/index.js\";\nimport type {\n  DocumentNode,\n  FormattedExecutionResult,\n  GraphQLFormattedError,\n} from \"graphql\";\n\nimport type { Operation } from \"../core/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport type {\n  Observer,\n  ObservableSubscription,\n} from \"../../utilities/index.js\";\nimport { Observable, compact, isNonEmptyArray } from \"../../utilities/index.js\";\nimport type { NetworkError } from \"../../errors/index.js\";\nimport type { ServerError } from \"../utils/index.js\";\nimport {\n  cacheSizes,\n  AutoCleanedWeakCache,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\n\nexport const VERSION = 1;\n\nexport interface ErrorResponse {\n  graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;\n  networkError?: NetworkError;\n  response?: FormattedExecutionResult;\n  operation: Operation;\n  meta: ErrorMeta;\n}\n\ntype ErrorMeta = {\n  persistedQueryNotSupported: boolean;\n  persistedQueryNotFound: boolean;\n};\n\ntype SHA256Function = (...args: any[]) => string | PromiseLike<string>;\ntype GenerateHashFunction = (\n  document: DocumentNode\n) => string | PromiseLike<string>;\n\ninterface BaseOptions {\n  disable?: (error: ErrorResponse) => boolean;\n  retry?: (error: ErrorResponse) => boolean;\n  useGETForHashedQueries?: boolean;\n}\n\nexport namespace PersistedQueryLink {\n  interface SHA256Options extends BaseOptions {\n    sha256: SHA256Function;\n    generateHash?: never;\n  }\n\n  interface GenerateHashOptions extends BaseOptions {\n    sha256?: never;\n    generateHash: GenerateHashFunction;\n  }\n\n  export type Options = SHA256Options | GenerateHashOptions;\n}\n\nfunction processErrors(\n  graphQLErrors:\n    | GraphQLFormattedError[]\n    | ReadonlyArray<GraphQLFormattedError>\n    | undefined\n): ErrorMeta {\n  const byMessage = Object.create(null),\n    byCode = Object.create(null);\n\n  if (isNonEmptyArray(graphQLErrors)) {\n    graphQLErrors.forEach((error) => {\n      byMessage[error.message] = error;\n      if (typeof error.extensions?.code == \"string\")\n        byCode[error.extensions.code] = error;\n    });\n  }\n  return {\n    persistedQueryNotSupported: !!(\n      byMessage.PersistedQueryNotSupported ||\n      byCode.PERSISTED_QUERY_NOT_SUPPORTED\n    ),\n    persistedQueryNotFound: !!(\n      byMessage.PersistedQueryNotFound || byCode.PERSISTED_QUERY_NOT_FOUND\n    ),\n  };\n}\n\nconst defaultOptions: Required<BaseOptions> = {\n  disable: ({ meta }) => meta.persistedQueryNotSupported,\n  retry: ({ meta }) =>\n    meta.persistedQueryNotSupported || meta.persistedQueryNotFound,\n  useGETForHashedQueries: false,\n};\n\nfunction operationDefinesMutation(operation: Operation) {\n  return operation.query.definitions.some(\n    (d) => d.kind === \"OperationDefinition\" && d.operation === \"mutation\"\n  );\n}\n\nexport const createPersistedQueryLink = (\n  options: PersistedQueryLink.Options\n) => {\n  let hashesByQuery:\n    | AutoCleanedWeakCache<DocumentNode, Promise<string>>\n    | undefined;\n  function resetHashCache() {\n    hashesByQuery = undefined;\n  }\n  // Ensure a SHA-256 hash function is provided, if a custom hash\n  // generation function is not provided. We don't supply a SHA-256 hash\n  // function by default, to avoid forcing one as a dependency. Developers\n  // should pick the most appropriate SHA-256 function (sync or async) for\n  // their needs/environment, or provide a fully custom hash generation\n  // function (via the `generateHash` option) if they want to handle\n  // hashing with something other than SHA-256.\n  invariant(\n    options &&\n      (typeof options.sha256 === \"function\" ||\n        typeof options.generateHash === \"function\"),\n    'Missing/invalid \"sha256\" or \"generateHash\" function. Please ' +\n      'configure one using the \"createPersistedQueryLink(options)\" options ' +\n      \"parameter.\"\n  );\n\n  const {\n    sha256,\n    // If both a `sha256` and `generateHash` option are provided, the\n    // `sha256` option will be ignored. Developers can configure and\n    // use any hashing approach they want in a custom `generateHash`\n    // function; they aren't limited to SHA-256.\n    generateHash = (query: DocumentNode) =>\n      Promise.resolve<string>(sha256!(print(query))),\n    disable,\n    retry,\n    useGETForHashedQueries,\n  } = compact(defaultOptions, options);\n\n  let supportsPersistedQueries = true;\n\n  const getHashPromise = (query: DocumentNode) =>\n    new Promise<string>((resolve) => resolve(generateHash(query)));\n\n  function getQueryHash(query: DocumentNode): Promise<string> {\n    if (!query || typeof query !== \"object\") {\n      // If the query is not an object, we won't be able to store its hash as\n      // a property of query[hashesKey], so we let generateHash(query) decide\n      // what to do with the bogus query.\n      return getHashPromise(query);\n    }\n    if (!hashesByQuery) {\n      hashesByQuery = new AutoCleanedWeakCache(\n        cacheSizes[\"PersistedQueryLink.persistedQueryHashes\"] ||\n          defaultCacheSizes[\"PersistedQueryLink.persistedQueryHashes\"]\n      );\n    }\n    let hash = hashesByQuery.get(query);\n    if (!hash) hashesByQuery.set(query, (hash = getHashPromise(query)));\n    return hash;\n  }\n\n  return Object.assign(\n    new ApolloLink((operation, forward) => {\n      invariant(\n        forward,\n        \"PersistedQueryLink cannot be the last link in the chain.\"\n      );\n\n      const { query } = operation;\n\n      return new Observable((observer: Observer<FormattedExecutionResult>) => {\n        let subscription: ObservableSubscription;\n        let retried = false;\n        let originalFetchOptions: any;\n        let setFetchOptions = false;\n        const maybeRetry = (\n          {\n            response,\n            networkError,\n          }: {\n            response?: FormattedExecutionResult;\n            networkError?: ServerError;\n          },\n          cb: () => void\n        ) => {\n          if (!retried && ((response && response.errors) || networkError)) {\n            retried = true;\n\n            const graphQLErrors: GraphQLFormattedError[] = [];\n\n            const responseErrors = response && response.errors;\n            if (isNonEmptyArray(responseErrors)) {\n              graphQLErrors.push(...responseErrors);\n            }\n\n            // Network errors can return GraphQL errors on for example a 403\n            let networkErrors;\n            if (typeof networkError?.result !== \"string\") {\n              networkErrors =\n                networkError &&\n                networkError.result &&\n                (networkError.result.errors as GraphQLFormattedError[]);\n            }\n            if (isNonEmptyArray(networkErrors)) {\n              graphQLErrors.push(...networkErrors);\n            }\n\n            const disablePayload: ErrorResponse = {\n              response,\n              networkError,\n              operation,\n              graphQLErrors:\n                isNonEmptyArray(graphQLErrors) ? graphQLErrors : void 0,\n              meta: processErrors(graphQLErrors),\n            };\n\n            // if the server doesn't support persisted queries, don't try anymore\n            supportsPersistedQueries = !disable(disablePayload);\n            if (!supportsPersistedQueries) {\n              // clear hashes from cache, we don't need them anymore\n              resetHashCache();\n            }\n\n            // if its not found, we can try it again, otherwise just report the error\n            if (retry(disablePayload)) {\n              // need to recall the link chain\n              if (subscription) subscription.unsubscribe();\n              // actually send the query this time\n              operation.setContext({\n                http: {\n                  includeQuery: true,\n                  includeExtensions: supportsPersistedQueries,\n                },\n                fetchOptions: {\n                  // Since we're including the full query, which may be\n                  // large, we should send it in the body of a POST request.\n                  // See issue #7456.\n                  method: \"POST\",\n                },\n              });\n              if (setFetchOptions) {\n                operation.setContext({ fetchOptions: originalFetchOptions });\n              }\n              subscription = forward(operation).subscribe(handler);\n\n              return;\n            }\n          }\n          cb();\n        };\n        const handler = {\n          next: (response: FormattedExecutionResult) => {\n            maybeRetry({ response }, () => observer.next!(response));\n          },\n          error: (networkError: ServerError) => {\n            maybeRetry({ networkError }, () => observer.error!(networkError));\n          },\n          complete: observer.complete!.bind(observer),\n        };\n\n        // don't send the query the first time\n        operation.setContext({\n          http: {\n            includeQuery: !supportsPersistedQueries,\n            includeExtensions: supportsPersistedQueries,\n          },\n        });\n\n        // If requested, set method to GET if there are no mutations. Remember the\n        // original fetchOptions so we can restore them if we fall back to a\n        // non-hashed request.\n        if (\n          useGETForHashedQueries &&\n          supportsPersistedQueries &&\n          !operationDefinesMutation(operation)\n        ) {\n          operation.setContext(\n            ({ fetchOptions = {} }: { fetchOptions: Record<string, any> }) => {\n              originalFetchOptions = fetchOptions;\n              return {\n                fetchOptions: {\n                  ...fetchOptions,\n                  method: \"GET\",\n                },\n              };\n            }\n          );\n          setFetchOptions = true;\n        }\n\n        if (supportsPersistedQueries) {\n          getQueryHash(query)\n            .then((sha256Hash) => {\n              operation.extensions.persistedQuery = {\n                version: VERSION,\n                sha256Hash,\n              };\n              subscription = forward(operation).subscribe(handler);\n            })\n            .catch(observer.error!.bind(observer));\n        } else {\n          subscription = forward(operation).subscribe(handler);\n        }\n\n        return () => {\n          if (subscription) subscription.unsubscribe();\n        };\n      });\n    }),\n    {\n      resetHashCache,\n    },\n    __DEV__ ?\n      {\n        getMemoryInternals() {\n          return {\n            PersistedQueryLink: {\n              persistedQueryHashes: hashesByQuery?.size ?? 0,\n            },\n          };\n        },\n      }\n    : {}\n  );\n};\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}
